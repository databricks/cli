#!/bin/bash

# First deploy the bundle so we have something to destroy
$CLI bundle deploy --auto-approve

# Start destroy in background, redirecting stderr to capture when destroy starts
$CLI bundle destroy --auto-approve 2>&1 &
DESTROY_PID=$!

# Wait for destroy to start by monitoring for job deletion request
title "Wait until the destroy has started."
for i in {1..30}; do
  if [ -f out.requests.txt ] && jq -e 'select(.method == "POST" and (.path | contains("/api/2.2/jobs/delete")))' out.requests.txt >/dev/null 2>&1; then
    echo "Destroy in progress, sending interrupt signal..."
    break
  fi
  sleep 0.1
done

# Send interrupt signal
trace kill -INT $DESTROY_PID

# Wait for process to complete
errcode trace wait $DESTROY_PID

# A deletion request for destroy.lock should have been recorded in the requests file
trace cat out.requests.txt | jq 'select(.method == "POST" and (.path | contains("workspace/delete")) and (.body.path | contains("destroy.lock")))'

title "A deletion request for job2 should be recorded in the requests file. No request for job1 should exist since the process was terminated mid destroy."
trace cat out.requests.txt | jq 'select(.method == "POST" and (.path | contains("/api/2.2/jobs/delete")))'

trace $CLI bundle debug plan

rm out.requests.txt
