print_requests() {
    jq --sort-keys 'select(.method != "GET" and (.path | contains("/jobs")))' < out.requests.txt
    rm out.requests.txt
}

print_sorted_requests() {
    jq -c < out.requests.txt | sort | jq --sort-keys 'select(.method != "GET" and (.path | contains("/jobs")))'
    rm out.requests.txt
}

echo "*" > .gitignore
# In direct, plan is sorted by deployment order. In TF it comes back sorted alphabetically.
# I think deployment order is better, sorting here to remove the mismatch
trace $CLI bundle plan 2>&1 | sort
trace $CLI bundle deploy
trace print_requests

foo_id=`read_id.py jobs foo`
echo "$foo_id:FOO_ID" >> ACC_REPLS

bar_id=`read_id.py jobs bar`
echo "$bar_id:BAR_ID" >> ACC_REPLS

trace $CLI bundle plan

title "Update trigger.periodic.unit and re-deploy"
trace update_file.py databricks.yml DAYS HOURS
trace $CLI bundle plan
trace $CLI bundle deploy
trace print_requests
trace $CLI bundle plan

title "Fetch job ID and verify remote state"

trace $CLI jobs get $foo_id
trace $CLI jobs get $bar_id
rm out.requests.txt

title "Destroy the job and verify that it's removed from the state and from remote"
trace $CLI bundle destroy --auto-approve
# TF deletes bar first, direct deletes everything in parallel
# If Terraform's order due to it reverting deployment order, we need to implement that as well.
trace print_sorted_requests

trace musterr $CLI jobs get $foo_id
trace musterr $CLI jobs get $bar_id
rm out.requests.txt
