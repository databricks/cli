#!/bin/bash

# Cleanup function to delete both branches
cleanup() {
   # Try to delete with current config
   trace $CLI bundle destroy --auto-approve

   # Also try to delete the old branch directly in case it wasn't cleaned up
   $CLI postgres delete-branch "projects/test-pg-proj-${UNIQUE_NAME}/branches/old-branch-${UNIQUE_NAME}" 2>/dev/null || true
}
trap cleanup EXIT

# Deploy with first branch_id
envsubst < databricks.yml.tmpl | sed "s/BRANCH_ID_PLACEHOLDER/old-branch-${UNIQUE_NAME}/" > databricks.yml

trace cat databricks.yml

trace $CLI bundle plan
rm -f out.requests.txt
trace $CLI bundle deploy

branch_id_1=`read_id.py main`

print_requests() {
    local name=$1
    jq --sort-keys 'select(.method != "GET" and (.path | contains("/postgres")))' < out.requests.txt > out.requests.${name}.$DATABRICKS_BUNDLE_ENGINE.txt
    rm -f out.requests.txt
}

print_requests create

title "Change branch_id (should trigger recreation in direct, update in terraform)"
sed "s/old-branch-${UNIQUE_NAME}/new-branch-${UNIQUE_NAME}/" databricks.yml > databricks.yml.new
mv databricks.yml.new databricks.yml

trace cat databricks.yml

# Plan output differs between engines (recreate vs update)
$CLI bundle plan > out.plan.$DATABRICKS_BUNDLE_ENGINE.txt 2>&1
trace $CLI bundle deploy --auto-approve

print_requests update

title "Fetch new branch ID"
branch_id_2=`read_id.py main`
# Get output differs between engines (different branch IDs)
$CLI postgres get-branch $branch_id_2 | jq 'del(.create_time, .update_time)' > out.get_branch.$DATABRICKS_BUNDLE_ENGINE.txt

title "Destroy and verify cleanup"
trace $CLI bundle destroy --auto-approve

print_requests destroy

# Clean up any orphaned old branch (terraform doesn't delete it on recreation)
$CLI postgres delete-branch $branch_id_1 2>/dev/null || true

rm -f out.requests.txt

