print_requests() {
    jq --sort-keys 'select(.method != "GET" and (.path | (contains("/jobs") or contains("/pipelines"))))' < out.requests.txt
    rm out.requests.txt
}

print_sorted_requests() {
    jq -c < out.requests.txt | sort | jq --sort-keys 'select(.method != "GET" and (.path | (contains("/jobs") or contains("/pipelines"))))'
    rm out.requests.txt
}

echo "*" > .gitignore
trace $CLI bundle plan
$CLI bundle debug plan > out.plan_create.$DATABRICKS_BUNDLE_ENGINE.json
trace $CLI bundle deploy
trace print_requests

foo_id=`read_id.py pipelines foo`
echo "$foo_id:FOO_ID" >> ACC_REPLS

bar_id=`read_id.py jobs bar`
echo "$bar_id:BAR_ID" >> ACC_REPLS

trace $CLI bundle plan  # empty

title "Update catalog, triggering recreate for pipeline; this means updating downstream deps"
trace update_file.py databricks.yml mycatalog mynewcatalog
trace $CLI bundle plan
$CLI bundle debug plan > out.plan_update.$DATABRICKS_BUNDLE_ENGINE.json
trace $CLI bundle deploy --auto-approve
trace print_requests

foo_id_2=`read_id.py pipelines foo`
echo "$foo_id:FOO_ID_2" >> ACC_REPLS

title "Fetch resource IDs and verify remote state"

trace musterr $CLI pipelines get $foo_id
trace $CLI pipelines get $foo_id_2
trace $CLI jobs get $bar_id
rm out.requests.txt

title "Follow up plan & deploy do nothing"
trace $CLI bundle plan
$CLI bundle debug plan > out.plan_noop.$DATABRICKS_BUNDLE_ENGINE.json
trace $CLI bundle deploy
trace print_requests

trace $CLI bundle destroy --auto-approve
# Sort, because the order of requests is different. TODO: remember deps in order to delete in reverse deployment order.
trace print_sorted_requests

trace musterr $CLI pipelines get $foo_id
trace musterr $CLI pipelines get $foo_id_2
trace musterr $CLI jobs get $bar_id
rm out.requests.txt
