title "Bind volume test: "

title "Substitute variables in the template: "
BUNDLE_NAME_SUFFIX=$(uuid)
export BUNDLE_NAME_SUFFIX

VOLUME_NAME="volume-$(uuid)"
SCHEMA_NAME="test-schema-$(uuid)"
if [ -z "$CLOUD_ENV" ]; then
    VOLUME_NAME="volume-6260d50f-e8ff-4905-8f28-812345678903"   # use hard-coded uuid when running locally
    SCHEMA_NAME="test-schema-6260d50f-e8ff-4905-8f28-812345678903"
fi
export VOLUME_NAME
export SCHEMA_NAME
export CATALOG_NAME="main"
envsubst < databricks.yml > out.yml && mv out.yml databricks.yml

VOLUME_TYPE="MANAGED"

title "Create a pre-defined schema (volume requires a schema): "
$CLI schemas create "${SCHEMA_NAME}" ${CATALOG_NAME} | jq '{full_name, catalog_name}'

title "Create a pre-defined volume: "
VOLUME_FULL_NAME=$($CLI volumes create "${CATALOG_NAME}" "${SCHEMA_NAME}" "${VOLUME_NAME}" "${VOLUME_TYPE}" | jq -r '.full_name')

cleanupRemoveVolume() {
    title "Test cleanup: "
    title "Delete the pre-defined volume ${VOLUME_FULL_NAME}: "
    $CLI volumes delete "${VOLUME_FULL_NAME}"
    echo $?
}
trap cleanupRemoveVolume EXIT

title "Bind volume: "
$CLI bundle deployment bind volume1 "${VOLUME_FULL_NAME}" --auto-approve

title "Deploy bundle: "
$CLI bundle deploy

title "Read the pre-defined dashboard: "
$CLI volumes read "${VOLUME_FULL_NAME}" | jq '{catalog_name, full_name, schema_name, volume_type}'

title "Unbind the dashboard: "
$CLI bundle deployment unbind volume1

title "Destroy the bundle: "
$CLI bundle destroy --auto-approve

title "Read the pre-defined volume again (expecting it still exists): "
$CLI volumes read "${VOLUME_FULL_NAME}" | jq '{catalog_name, full_name, schema_name, volume_type}'
