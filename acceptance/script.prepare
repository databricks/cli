errcode() {
    # Temporarily disable 'set -e' to prevent the script from exiting on error
    set +e
    # Execute the provided command with all arguments
    "$@"
    local exit_code=$?
    # Re-enable 'set -e' if it was previously set
    set -e
    if [ $exit_code -ne 0 ]; then
        >&2 printf "\nExit code: $exit_code\n"
    fi
}

musterr() {
    # Temporarily disable 'set -e' to prevent the script from exiting on error
    set +e
    # Execute the provided command with all arguments
    "$@"
    local exit_code=$?
    # Re-enable 'set -e'
    set -e
    if [ $exit_code -eq 0 ]; then
        >&2 printf "\nUnexpected success\n"
        exit 1
    fi
}

trace() {
    >&2 printf "\n>>> %s\n" "$*"

    if [[ "$1" == *"="* ]]; then
        # If the first argument contains '=', collect all env vars
        local env_vars=()
        while [[ "$1" == *"="* ]]; do
            env_vars+=("$1")
            shift
        done
        # Export environment variables in a subshell and execute the command
        (
            export "${env_vars[@]}"
            "$@"
        )
    else
        # Execute the command normally
        "$@"
    fi

    return $?
}

git-repo-init() {
    git init -qb main
    git config core.autocrlf false
    git config user.name "Tester"
    git config user.email "tester@databricks.com"
    git config core.hooksPath no-hooks
    git add databricks.yml
    git commit -qm 'Add databricks.yml'
}

title() {
    local label="$1"
    printf "\n=== %b" "$label"
}

withdir() {
    local dir="$1"
    shift
    local orig_dir="$(pwd)"
    cd "$dir" || return $?
    "$@"
    local exit_code=$?
    cd "$orig_dir" || return $?
    return $exit_code
}

uuid() {
    python3 -c 'import uuid; print(uuid.uuid4())'
}

venv_activate() {
    if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]]; then
        source .venv/Scripts/activate
    else
        source .venv/bin/activate
    fi
}

envsubst() {
    # We need to disable MSYS_NO_PATHCONV when running the python script.
    # This is because the python interpreter is otherwise unable to find the python script
    # when MSYS_NO_PATHCONV is enabled.
    env -u MSYS_NO_PATHCONV envsubst.py
}

print_telemetry_bool_values() {
    jq -r 'select(.path? == "/telemetry-ext") | (.body.protoLogs // [])[] | fromjson | ( (.entry // .) | (.databricks_cli_log.bundle_deploy_event.experimental.bool_values // []) ) | map("\(.key) \(.value)") | .[]' out.requests.txt | sort
}

sethome() {
    local home="$1"
    mkdir -p "$home"

    # For macOS and Linux, use HOME.
    export HOME="$home"

    # For Windows, use USERPROFILE.
    export USERPROFILE="$home"
}

as-test-sp() {
    if [[ -z "$TEST_SP_TOKEN" ]]; then
        echo "Error: TEST_SP_TOKEN is not set." >&2
        return 1
    fi

    DATABRICKS_TOKEN="$TEST_SP_TOKEN" \
    DATABRICKS_CLIENT_SECRET="" \
    DATABRICKS_CLIENT_ID="" \
    DATABRICKS_AUTH_TYPE="" \
    "$@"
}
