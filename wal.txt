Design Document: Write-Ahead Log (WAL) for Bundle Deployment State Recovery
1. Problem Statement
When databricks bundle deploy is interrupted, resources created before the interruption become orphaned. The CLI only writes the state file at the end of deployment via Finalize(). Any resources created mid-deployment are lost from tracking.

Current behavior:
Deploy starts → Create Job A → Create Job B → [CRASH] → State file empty → Jobs A, B orphaned

Impact: Orphaned resources exist in Databricks but are unknown to future deployments. Users accumulate duplicate resources, leading to confusion and unexpected costs.

Scope: Direct deployment engine only. Terraform has its own state management.
2. Solution Overview
Implement a Write-Ahead Log (WAL) that records each state mutation to disk immediately after the corresponding API call succeeds.
On recovery, replay the WAL to restore partial deployment state.

Proposed behavior:
Deploy starts → Create Job A → [WAL: A] → Create Job B → [WAL: A,B] → [CRASH]
Next deploy → Load state → Replay WAL → State has A,B → No duplicates
3. Detailed Design
3.1 File Structure
The WAL is stored locally alongside the existing state file.

File Path
Description
~/.databricks/bundle/<name>/<target>/
Root directory for the bundle's state data.
~/.databricks/bundle/<name>/<target>/resources.json
The committed state file (existing).
~/.databricks/bundle/<name>/<target>/resources.json.wal
The Write-Ahead Log file (new).

3.2 WAL Entry Format
Each entry is a JSON object written as a single line (NDJSON format). The entry embeds the existing ResourceEntry structure for consistency with the state file.

Field
Type
Description
Lineage (First Entry Only)
String
UUID matching the state file's lineage (for validation).
Serial (First Entry Only)
Integer
Deployment serial number (for validation).
k (2nd Entry Onwards)
String
Resource key (e.g., resources.jobs.my_job).
v (2nd Entry Onwards)
ResourceEntry
The state entry. Omitted for delete operations.


ResourceEntry structure (existing, reused):

Field
Type
Description
__id__
String
The unique ID assigned by the Databricks API.
state
Object
Full snapshot of the resource configuration.


Example WAL:
{"lineage":"abc-123"}
{"k":"resources.jobs.my_job","v":{"__id__":"1234567","state":{...}}}
{"k":"resources.jobs.old_job"} // no v means delete op
3.3 WAL Lifecycle
Phase
Action
Open
Create or open resources.json.wal.
Write
Append entry after each successful API call.
Truncate
Delete resources.json.wal after successful Finalize().


Durability: Each entry must be flushed to disk (fsync) immediately after the successful API response before proceeding.
Known Limitation: There is a small window (~microseconds) between API success and WAL write where a crash would orphan the resource. This is unavoidable is acceptable.
3.4 Recovery Mechanism
Recovery occurs at the start of deployment if the WAL file exists.

Check: If resources.json.wal exists, initiate recovery.
Load Base State:
If resources.json exists: load it (provides lineage and serial). We are making sure it exists by writing immediately once we open/create it in the Open() method
Otherwise: create fresh state with new lineage.
Read WAL: Parse all entries from resources.json.wal (already chronologically ordered).
Validate Entries:
WAL serial == state serial + 1: Valid — replay entries.
WAL serial < state serial + 1: Stale WAL — delete WAL file, proceed without recovery.
WAL serial > state serial + 1: Corrupted state — return error.
Replay: For each valid entry:
set: Add or overwrite the resource in memory.
delete: Remove the resource from memory.
Proceed: Use the resulting state as the starting point for deployment.
Finalize: On success, write resources.json and delete resources.json.wal.
3.5 Integration Points
Action
Location
Detail
Recovery Check
Open() in dstate/state.go
Check for the WAL file and replay before proceeding.
Write WAL Entry
SaveState() / DeleteState()
Append entry before updating memory.
Truncation
Finalize()
Delete WAL after successful state file write.

3.6 Error Handling
Scenario
Behavior
WAL write fails
Return error, abort deployment.
Corrupted WAL line
Log warning, skip line, continue replay.
Lineage mismatch
Return error, abort deployment.
Stale serial
Delete WAL

5. Testing Plan
Use acceptance tests. Add support for the crash caller process from the test server.
Key test cases:
Tests which compile and run real binary against testserver.

Normal deploy — WAL created, used, deleted.
Crash after 1 resource — recovery works.
Fresh deploy with existing WAL — lineage adopted.
Stale WAL (old serial) — entries skipped.
Corrupted WAL line — skipped, rest recovered.
Bundle summary works after interrupted deploy and sees ids stored in WAL
7. Open Questions
#
Question
Proposed Answer
1
Should WAL be pushed to remote?
Never

5. Test Plan

We should use acceptance tests which compile and run real binary against testerver

5.1 Unit Tests - WAL File Operations
| Test ID | Description | Expected Behavior |
|---------|-------------|-------------------|
| U01 | WAL path generation | walPath("resources.json") returns "resources.json.wal" |
| U02 | Write and read WAL | Header + entries written and read back correctly |
| U03 | Truncate WAL | File deleted from disk |
| U04 | Truncate non-existent WAL | No error returned |
| U05 | Read empty WAL | Returns error "WAL file is empty or missing header" |

5.2 Unit Tests - WAL Recovery Logic
| Test ID | Description | Expected Behavior |
|---------|-------------|-------------------|
| R01 | No WAL exists | recoverFromWAL returns (false, nil) |
| R02 | Valid WAL (serial = state+1) | Entries replayed, returns (true, nil) |
| R03 | Stale WAL (serial < state+1) | WAL deleted, returns (false, nil) |
| R04 | Future WAL (serial > state+1) | Returns error about corruption |
| R05 | Lineage mismatch | Returns error about lineage mismatch |
| R06 | Lineage adopted from WAL | If state has no lineage, WAL lineage is used |
| R07 | Delete operation replay | Entry removed from state map |
| R08 | Corrupted entry line | Skipped, other entries recovered |

5.3 Unit Tests - Integration with DeploymentState
| Test ID | Description | Expected Behavior |
|---------|-------------|-------------------|
| I01 | SaveState/DeleteState/Finalize flow | WAL created on first SaveState, entries written, truncated on Finalize, serial incremented |
| I02 | Finalize cleans stale WAL | If WAL file exists but wasn't opened this session, delete it |
| I03 | Open with existing WAL | Recovery performed before return |
| I04 | SaveState with DependsOn | DependsOn preserved in WAL entry |

5.4 Acceptance Tests
| Test ID | Description | Steps | Expected Behavior |
|---------|-------------|-------|-------------------|
| A01 | Normal deploy | Deploy bundle with 2 resources | WAL created during deploy, deleted after Finalize |
| A02 | Crash recovery | 1. Deploy, crash after resource A created 2. Redeploy | Resource A recovered from WAL, resource B created, no duplicates |
| A03 | Bundle summary after crash | 1. Deploy, crash mid-deploy 2. Run bundle summary | Shows resources from WAL with correct IDs |

5.5 Tests Implemented in wal_test.go
- TestWALPath (U01)
- TestWALWriteAndRead (U02)
- TestWALTruncate (U03, U04)
- TestRecoverFromWAL_NoWAL (R01)
- TestRecoverFromWAL_ValidWAL (R02)
- TestRecoverFromWAL_StaleWAL (R03)
- TestRecoverFromWAL_FutureWAL (R04)
- TestRecoverFromWAL_LineageMismatch (R05)
- TestRecoverFromWAL_DeleteOperation (R07)
- TestRecoverFromWAL_CorruptedLine (R08)
- TestDeploymentState_WALIntegration (I01)
- TestDeploymentState_WALRecoveryOnOpen (I03)
- TestDeploymentState_DeleteStateWritesWAL (I01)
- TestDeploymentState_WALWithDependsOn (I04)

5.6 Tests Still Needed
| Test ID | Description | Priority |
|---------|-------------|----------|
| R06 | TestRecoverFromWAL_LineageAdoption (fresh state adopts WAL lineage) | High |
| I02 | TestDeploymentState_FinalizeCleansStaleWAL | Medium |
| U05 | TestReadEmptyWAL | Low |
| A01-A03 | Acceptance tests (require crash simulation infrastructure) | High |
