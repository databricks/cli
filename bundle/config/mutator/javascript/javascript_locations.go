package javascript

import (
	"encoding/json"
	"fmt"
	"io"
	pathlib "path"
	"path/filepath"

	"github.com/databricks/cli/libs/dyn"
)

// generatedFileName is used as the virtual file name for YAML generated by JavaScript code.
const generatedFileName = "__generated_by_javascript__.yml"

// javaScriptLocations is data structure for efficient location lookup for a given path
type javaScriptLocations struct {
	// descendants referenced by index, e.g. '.foo'
	keys map[string]*javaScriptLocations

	// descendants referenced by key, e.g. '[0]'
	indexes map[int]*javaScriptLocations

	// location for the current node if it exists
	location dyn.Location

	// if true, location is present
	exists bool
}

// javaScriptLocationEntry is a single entry in locations.json
type javaScriptLocationEntry struct {
	Path   string `json:"path"`
	File   string `json:"file"`
	Line   int    `json:"line"`
	Column int    `json:"column"`
}

// mergeJavaScriptLocations applies locations from JavaScript mutator into given dyn.Value
func mergeJavaScriptLocations(value dyn.Value, locations *javaScriptLocations) (dyn.Value, error) {
	return dyn.Walk(value, func(path dyn.Path, value dyn.Value) (dyn.Value, error) {
		newLocation, ok := findJavaScriptLocation(locations, path)
		if !ok {
			return value, nil
		}

		// The first item in the list is the "last" location used for error reporting
		newLocations := append(
			[]dyn.Location{newLocation},
			removeVirtualLocations(value.Locations())...,
		)

		return value.WithLocations(newLocations), nil
	})
}

func removeVirtualLocations(locations []dyn.Location) []dyn.Location {
	var newLocations []dyn.Location

	for _, location := range locations {
		if filepath.Base(location.File) == generatedFileName {
			continue
		}

		newLocations = append(newLocations, location)
	}

	return newLocations
}

// parseJavaScriptLocations parses locations.json from the JavaScript mutator.
//
// locations file is newline-separated JSON objects with javaScriptLocationEntry structure.
func parseJavaScriptLocations(bundleRoot string, input io.Reader) (*javaScriptLocations, error) {
	decoder := json.NewDecoder(input)
	locations := newJavaScriptLocations()

	for decoder.More() {
		var entry javaScriptLocationEntry

		err := decoder.Decode(&entry)
		if err != nil {
			return nil, fmt.Errorf("failed to parse javascript location: %s", err)
		}

		path, err := dyn.NewPathFromString(entry.Path)
		if err != nil {
			return nil, fmt.Errorf("failed to parse javascript location: %s", err)
		}

		// Output can contain both relative paths and absolute paths outside of bundle root.
		// Mutator pipeline expects all path to be absolute at this point, so make all paths absolute.
		if !pathlib.IsAbs(entry.File) {
			entry.File = filepath.Join(bundleRoot, entry.File)
		}

		location := dyn.Location{
			File:   entry.File,
			Line:   entry.Line,
			Column: entry.Column,
		}

		putJavaScriptLocation(locations, path, location)
	}

	return locations, nil
}

// putJavaScriptLocation puts the location to the trie for the given path
func putJavaScriptLocation(trie *javaScriptLocations, path dyn.Path, location dyn.Location) {
	currentNode := trie

	for _, component := range path {
		if key := component.Key(); key != "" {
			if _, ok := currentNode.keys[key]; !ok {
				currentNode.keys[key] = newJavaScriptLocations()
			}

			currentNode = currentNode.keys[key]
		} else {
			index := component.Index()
			if _, ok := currentNode.indexes[index]; !ok {
				currentNode.indexes[index] = newJavaScriptLocations()
			}

			currentNode = currentNode.indexes[index]
		}
	}

	currentNode.location = location
	currentNode.exists = true
}

// newJavaScriptLocations creates a new trie node
func newJavaScriptLocations() *javaScriptLocations {
	return &javaScriptLocations{
		keys:    make(map[string]*javaScriptLocations),
		indexes: make(map[int]*javaScriptLocations),
	}
}

// findJavaScriptLocation finds the location or closest ancestor location in the trie for the given path
// if no ancestor or exact location is found, false is returned.
func findJavaScriptLocation(locations *javaScriptLocations, path dyn.Path) (dyn.Location, bool) {
	currentNode := locations
	lastLocation := locations.location
	exists := locations.exists

	for _, component := range path {
		if key := component.Key(); key != "" {
			if _, ok := currentNode.keys[key]; !ok {
				break
			}

			currentNode = currentNode.keys[key]
		} else {
			index := component.Index()
			if _, ok := currentNode.indexes[index]; !ok {
				break
			}

			currentNode = currentNode.indexes[index]
		}

		if currentNode.exists {
			lastLocation = currentNode.location
			exists = true
		}
	}

	return lastLocation, exists
}
