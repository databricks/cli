package required

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"text/template"

	"github.com/databricks/cli/bundle/config"
	"github.com/databricks/cli/libs/structdiff/structpath"
	"github.com/databricks/cli/libs/structwalk"
)

type PatternInfo struct {
	// The pattern for which the fields in Required are applicable.
	// This is a string representation of [dyn.Parent].
	Parent string

	// List of required fields that should be set for every path in the
	// config tree that matches the pattern. This field be a string of the
	// form `{field1, field2, ...}`.
	RequiredFields string
}

func requiredFields(typ reflect.Type) []PatternInfo {
	// Group the required fields by the name of their top level field. This allow for better formatting
	// in the generated code.
	// out := map[string][]PatternInfo{}

	patterns := map[string][]string{}
	structwalk.WalkType(typ, func(path *structpath.PathNode, _ reflect.Type) error {
		// Do not perform required validation on fields that are deprecated, internal, or readonly.
		bundleTag := path.BundleTag()
		if bundleTag.Deprecated() || bundleTag.Internal() || bundleTag.ReadOnly() {
			return structwalk.ErrSkipWalk
		}

		// The "omitempty" tag indicates the field is optional in bundle config.
		if path.JSONTag().OmitEmpty() {
			return nil
		}

		// Only perform required validation for struct fields.
		field, ok := path.Field()
		if !ok {
			return nil
		}

		parentPath := path.Parent().DynPath()
		if _, ok := patterns[parentPath]; !ok {
			patterns[parentPath] = []string{}
		}
		patterns[parentPath] = append(patterns[parentPath], field)
		return nil
	})

	out := []PatternInfo{}
	for k, requiredFields := range patterns {
		requiredList := strings.Builder{}
		for i, r := range requiredFields {
			if i == 0 {
				requiredList.WriteString("{")
			}
			requiredList.WriteString(fmt.Sprintf("%q", r))
			if i < len(requiredFields)-1 {
				requiredList.WriteString(", ")
			}
			if i == len(requiredFields)-1 {
				requiredList.WriteString("}")
			}
		}
		out = append(out, PatternInfo{
			Parent:         k,
			RequiredFields: requiredList.String(),
		})
	}
	return out
}

func RequiredFields() [][]PatternInfo {
	patterns := requiredFields(reflect.TypeOf(config.Root{}))

	// Group the required fields by the name of their top level field. This allow for better rendering.
	patternMap := map[string][]PatternInfo{}
	for _, pattern := range patterns {
		parts := strings.Split(pattern.Parent, ".")

		var k string
		if parts[0] == "resources" {
			// Group resources by their type.
			k = parts[0] + "." + parts[1]
		} else if parts[0] == "targets" {
			// group target overrides by their first 3 keys
			k = parts[0] + "." + parts[1] + "." + parts[2]
		} else {
			// Just use the top level key for other fields.
			k = parts[0]
		}

		patternMap[k] = append(patternMap[k], PatternInfo{
			Parent:         pattern.Parent,
			RequiredFields: pattern.RequiredFields,
		})
	}

	// Convert map to an array to make it easier to render.
	sortedNodeMap := make([][]PatternInfo, 0, len(patternMap))
	var sortedKeys []string
	for k := range patternMap {
		sortedKeys = append(sortedKeys, k)
	}
	sort.Strings(sortedKeys)
	for _, k := range sortedKeys {
		sort.Slice(patternMap[k], func(i, j int) bool {
			return patternMap[k][i].Parent < patternMap[k][j].Parent
		})
		sortedNodeMap = append(sortedNodeMap, patternMap[k])
	}

	return sortedNodeMap
}

func Generate(outPath string) error {
	requiredFields := RequiredFields()

	// Ensure output directory exists
	err := os.MkdirAll(outPath, 0o755)
	if err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse the template
	tmpl, err := template.New("validation").Parse(validationTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Execute the template
	var generatedCode bytes.Buffer
	err = tmpl.Execute(&generatedCode, requiredFields)
	if err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Write the generated code to a file
	filePath := filepath.Join(outPath, "required_fields.go")
	err = os.WriteFile(filePath, generatedCode.Bytes(), 0o644)
	if err != nil {
		return fmt.Errorf("failed to write generated code: %w", err)
	}

	return nil
}

// validationTemplate is the Go text template for generating the map.
const validationTemplate = `package generated
// THIS FILE IS AUTOGENERATED.
// DO NOT EDIT THIS FILE DIRECTLY.

import (
	_ "github.com/databricks/cli/libs/dyn"
)

// RequiredFields maps [dyn.Pattern] to required fields they should have.
var RequiredFields = map[string][]string{
{{- range .}}
{{range .}}	"{{.Parent}}": {{.RequiredFields}},
{{end}}{{end -}}
}
`
